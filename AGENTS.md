## Development Workflow

### Phase 1: Exploration (BEFORE Modifying)

- **Analyze Structure:** Review the directory tree to understand the module
  hierarchy.
- **Check Capabilities:** Read `deno.json` to identify available `tasks` and
  import maps. Always use the defined import aliases and include file extensions
  (e.g., .ts) in imports.
- **Consistency Check:** Examine existing implementations of similar
  properties/methods/parameters. Match the existing design patterns and naming
  conventions exactly.
- **Architectural Placement:** If the logic is a generic utility, place it in
  `src/helpers/`. If the logic is domain-specific, place it within the relevant
  class/file.

### Phase 2: Implementation (DURING Development)

- **Strict Typing:** Avoid `any`. Use explicit interfaces and types.
- **Documentation:** Every new public property, method, or parameter must have a
  JSDoc block.
  - Include a clear description.
  - Include at least one `@example`.
  - Update `@param` and `@returns` tags accurately.
  - Match existing JSDoc block styling.
  - If modifying existing code, ensure all related JSDoc remains synchronized
    with the logic.

### Phase 3: Validation (AFTER Modifying)

- **Code Quality:** Run `deno lint`, `deno fmt`, and `deno check`. All must pass
  without warnings.
- **Testing:**
  - Update existing tests in `test/unit/` or create a new `.test.ts` file if
    none exists.
  - Run tests using `deno test` (or the specific `deno task` defined in
    `deno.json`).
- **Documentation Integrity:** Ensure JSDoc remains accurate if you have to
  modify the code to pass the tests.

### Files to ignore

Do not manually edit `llm.md`, as it is autogenerated from your JSDoc comments.
